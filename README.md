# uber_highload

## 1. Целевая аудитория
- 91 млн. активных пользователей
- 4 млн. водителей-партнеров
- 14 млн. поездок ежедневно
- Основная аудитория сервиса находится в северной Америке и Европе

## 2. Расчет нагрузки

В городе Нью-Йорке, где очень много пользуются такси, в начале 2020 года, в день совершалось около 520к поездок, при 69к водителей на линии https://www.businessofapps.com/data/uber-statistics/. Возьмем эту статистику и рассчитаем, сколько примерно водителей на линии в мире одновременно:
**14 000к / 520к * 69к = 1 858к**

Водители будут каждые 3 секунды отсылать свои координаты.
1 858 000 / 3 = 619 334 rps.
Водитель посылает свой id (4 байта), широту (8 байт), долготу (8 байт).
Каждый 3 секунды, водители будут присылать 36Мб данных о своем местоположении. В день будет перадавься 1Тб данных с местоположением водителей.
Для экономии трафика водителей данные будем передавать по UDP, т.к. данные не критичны и мы можем их терять.

Расчитаем пиковую нагрузку, которую создают клиенты. 14 000 000 / 86 400 * 3 = 486 rps.
На запрос пользователя, будем выдавать максимум 5 ближайших машин.

|         | Кол-во RPS|
|---------| ----------|
|Водители | 619к      |
|Клиенты  | 500       |

## 3. Логическая схема базы данных
![Снимок экрана 2021-05-27 в 22 46 56](https://user-images.githubusercontent.com/43621139/119889890-cee6a900-bf3f-11eb-9389-27fb04d48410.png)


## 4. Физическая схема базы данных
- для хранения информации о клиентах, водителях, поездках будем использовать Postgres
- для хранения геолокации водителей будем использовать Postgres вместе с расширением PostGIS
- для сессий водителей и клиентов возьмем Redis

Для базы данных с геопозицией будем использовать шардирование. Шардирование будет делаться на основании геопозиции водителя. Выделим в США и Европе города, в которых больше всего пользуются такси и сделаем для них отдельные шарды. Выбор в какой шард делать запрос будет делаться на уровне сервиса геолокации на основании геополокации клиента.

Также для надеждность воспользуемся репликацией. Использовать будем схему мастер - реплика. На каждый шард будет отдельный мастер и 2 реплики. Читать будем из реплик, в случае, если мастер упал, одна из реплик становится мастером.
![Снимок экрана 2021-05-27 в 22 46 56 2](https://user-images.githubusercontent.com/43621139/119889902-d312c680-bf3f-11eb-88b4-e069742efd7e.png)



## 5. Выбор технологий
В качестве языка для backend разработки выберем Go. Это компилируемый, статически типизуермый язык. Он достаточно производительный и потребляет адекватное количество ресурсов. Он прост в изучении, что позволит нанимать программистов с опытом работы на других языках. Упор будем делать на мобильные приложения, поэтому для их разработки выберем языки Swift и Kotlin. Для организации очередей будем использовать kafka.

## 6. Схема проекта
![Снимок экрана 2021-05-28 в 17 21 22](https://user-images.githubusercontent.com/43621139/119998433-5d5b3900-bfd9-11eb-9850-6e38e8bfc6f1.png)



